\documentclass{practice}

\title{9}
\subtitle{RSA attacks}
\date{\DTMdate{2024-11-06}}

\begin{document}
\maketitle

\begin{task}{Sharing is caring}
  % p = 5, q = 13
  % e1 = 5, d1 = 29
  % e2 = 7, d2 = 7
  % m = 4
  Let $n = 65$ be the RSA modulus generated by a trusted server, and let $e_A = 5, e_B = 7$ be two RSA public keys of two clients $A, B$.
  You intercept an encrypted broadcast to parties $A,B$: $c_A=49, c_B=4$ sent to $A, B$.
  Recover the broadcast message.
\end{task}

\begin{task}{Get to the root}
  Given $12^2 \equiv 1 \pmod{143}$, factor $143$.
\end{task}

\begin{task}{Lucky number}
  % (5*11=55, 3)
  % (3*17=51, 3)
  % (2*29=58, 3)
  % m = 5
  Let there be a server and three clients with RSA public keys
  \[
    \pk_1=(55, 3),\qquad \pk_2=(51, 3),\qquad \pk_3=(58, 3).
  \]
  The server then sends an encrypted broadcast to all parties with
  \[
    c_1 = 15,\qquad c_2 = 23,\qquad c_3 = 9.
  \]
  Recover the broadcast message.
\end{task}

\begin{task}{Restricted access}
  Last week we showed that textbook RSA is not IND-CCA2-secure, even under the following restrictions:
  \begin{itemize}
    \item we were limited to a single post-challenge query,
    \item we were not allowed to encrypt $m_0, m_1$ ourselves, or to query the oracle for their encryptions.
  \end{itemize}
  Is textbook RSA IND-CCA1-secure under the following restriction:
  you cannot encrypt $m_0, m_1$ yourself, and the challenger does not accept them if it has already seen them.
  Without this restriction, the game would be no different from the IND-CPA game.
\end{task}

\begin{task}{Meet in the middle}
  Let an RSA public key be made up of $64$ bits.
  Can you think of an algorithm which can perform a successful ciphertext only attack on textbook RSA on your own computer?

  To put things into perspective, and empty loop in C which iterates over the full $64$-bit space would run for about 680 years on my laptop, so brute force is not an option.
  The same loop iterated over the full $32$-bit space in about 5 seconds.

  Hint: take inspiration from the baby-step giant-step algorithm.
\end{task}

\newpage

\begin{center}
  Concept refresher
\end{center}

\begin{tcolorbox}[title=Chinese Remainder Theorem (CRT)]
  Given pairwise coprime integers $n_1, n_2, \dots, n_k$ and arbitrary integers $a_1, \dots, a_k$, the system of congruences:
  \[
    \begin{cases}
      x \equiv a_1 \pmod{n_1}\\
      x \equiv a_2 \pmod{n_2}\\
      \vdots\\
      x \equiv a_k \pmod{n_k}
    \end{cases}
  \]
  has a solution, and the solution is unique modulo $N = n_1n_2\dots n_k$.
  That is, if $x$ and $x'$ are both solutions, then $x \equiv x' \bmod{n_1n_2\dots n_k}$.
\end{tcolorbox}

The following is a general approach to finding the solution to a system of congruences using the CRT:
\begin{enumerate}
  \item Compute $N = n_1n_2\dots n_k$.
  \item For each $i=1,2,\dots,k$, compute
  \[
    y_i = \frac{N}{n_i} = n_1n_2\dots n_{i-1}n_{i+1}\dots n_k.
  \]
  \item For each $i$, compute $z_i \equiv y_i^{-1} \pmod{n_i}$ using the EEA.
  \item The integer $x = \sum_{i=1}^{k}a_iy_iz_i$ is a solution to the system.
\end{enumerate}

\end{document}
